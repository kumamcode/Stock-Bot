import os
import smtplib
from email.mime.text import MIMEText
from datetime import datetime
import requests
import schedule
import time
import sys
from dotenv import load_dotenv

load_dotenv()  # loads .env into os.environ

# ---------- LLM (local via Ollama) ----------
def ask_llm(prompt: str, model: str = "llama3.2:3b") -> str:
    r = requests.post(
        "http://localhost:11434/api/generate",
        json={"model": model, "prompt": prompt, "stream": False},
        timeout=180,
    )
    r.raise_for_status()
    return r.json()["response"].strip()

# ---------- Data (simple, free sources) ----------
def fetch_headlines():
    # Google News RSS (free)
    rss_url = "https://news.google.com/rss/search?q=stock+market+OR+fed+OR+inflation&hl=en-US&gl=US&ceid=US:en"
    xml = requests.get(rss_url, timeout=30).text
    # lightweight parse without extra deps
    items = xml.split("<item>")[1:6]
    titles = []
    for it in items:
        t = it.split("<title>")[1].split("</title>")[0]
        titles.append(t)
    return titles

def stooq_last_two_closes(symbol: str):
    # Stooq daily CSV, free no key
    url = f"https://stooq.com/q/d/l/?s={symbol}&i=d"
    csv = requests.get(url, timeout=30).text.strip().splitlines()
    if len(csv) < 3:
        raise RuntimeError(f"Not enough data for {symbol}")
    prev = csv[-2].split(",")
    last = csv[-1].split(",")
    # Date,Open,High,Low,Close,Volume
    return {
        "date": last[0],
        "prev_close": float(prev[4]),
        "close": float(last[4]),
    }

def pct_change(a, b):
    return (a - b) / b * 100.0

# ---------- Email ----------
def send_email(subject: str, body: str):
    gmail_user = os.environ.get("GMAIL_USER")
    gmail_app_password = os.environ.get("GMAIL_APP_PASSWORD")

    # TO_EMAIL, CC_EMAIL, BCC_EMAIL may be comma-separated lists in the env
    to_emails = [e.strip() for e in os.environ.get("TO_EMAIL", "").split(",") if e.strip()]
    cc_emails = [e.strip() for e in os.environ.get("CC_EMAIL", "").split(",") if e.strip()]
    bcc_emails = [e.strip() for e in os.environ.get("BCC_EMAIL", "").split(",") if e.strip()]

    if not gmail_user or not gmail_app_password:
        raise RuntimeError("GMAIL_USER and GMAIL_APP_PASSWORD must be set in environment")

    if not to_emails:
        raise RuntimeError("No recipient found. Set TO_EMAIL in environment (comma-separated for multiple).")

    msg = MIMEText(body, "plain", "utf-8")
    msg["Subject"] = subject
    msg["From"] = gmail_user
    msg["To"] = ", ".join(to_emails)
    if cc_emails:
        msg["Cc"] = ", ".join(cc_emails)

    # Actual delivery list includes To + Cc + Bcc
    all_recipients = to_emails + cc_emails + bcc_emails

    with smtplib.SMTP_SSL("smtp.gmail.com", 465) as server:
        server.login(gmail_user, gmail_app_password)
        server.sendmail(gmail_user, all_recipients, msg.as_string())

def main():
    # Pull a few market proxies
    spx = stooq_last_two_closes("^spx")  # S&P 500
    vix = stooq_last_two_closes("^vix")  # VIX

    spx_chg = pct_change(spx["close"], spx["prev_close"])
    vix_chg = pct_change(vix["close"], vix["prev_close"])

    headlines = fetch_headlines()

    # Personal config (edit these)
    user_profile = {
        "risk_tolerance": "medium-high",
        "time_horizon": "5+ years",
        "style": "mostly ETFs / long-term, however, hoping to make some strategic bets on individual stocks that are a bit riskier",
        "constraints": [
            "No leverage",
            "No day trading",
            "Prefer simple rules and explainable reasoning",
        ],
    }

    prompt = f"""
You are my personal investing memo writer. You must be cautious, avoid certainty, and avoid hype while considering market sentiment.
For context, I am an engineer with about 23,000 currently invested in my fidelity, mostly in ETFs, tech stocks, and international ETFs.
User profile:
- Risk tolerance: {user_profile["risk_tolerance"]}
- Horizon: {user_profile["time_horizon"]}
- Style: {user_profile["style"]}
- Constraints: {", ".join(user_profile["constraints"])}

Market snapshot (latest close vs previous close):
- S&P 500: {spx["close"]:.2f} ({spx_chg:+.2f}%)
- VIX: {vix["close"]:.2f} ({vix_chg:+.2f}%)

Top headlines:
{chr(10).join(f"- {h}" for h in headlines)}

Write a concise morning brief with:
1) 3 bullets: what matters today
2) A "risk regime" label (Risk-on / Neutral / Risk-off) with a 1-sentence justification
3) Suggested actions in general terms (allocation/rebalancing/DCA/cash buffer)
4) Suggest 6 Stocks that could provide long term growth and 
4) One thing to watch that could change the view

Keep it under 220 words.
"""

    brief = ask_llm(prompt)

    subject = f"Daily Investing Brief ({spx['date']})"
    body = brief + "\n\n Not Financial Advice -> Stock Bot created by Kuma McCraw"
    send_email(subject, body)

if __name__ == "__main__":
    # Manual run options for testing:
    #   python Stock_Bot_V1_main_py --run-now   (or -r)  -> run once and exit
    #   python Stock_Bot_V1_main_py --prompt    (or -p)  -> ask interactively whether to run now
    if "--run-now" in sys.argv or "-r" in sys.argv:
        print("Manual run requested (--run-now). Running once and exiting.")
        main()
        sys.exit(0)

    if "--prompt" in sys.argv or "-p" in sys.argv:
        try:
            ans = input("Run Stock Bot now? (y/N): ").strip().lower()
        except (EOFError, KeyboardInterrupt):
            ans = "n"
        if ans == "y":
            print("Running now...")
            main()
            sys.exit(0)
        else:
            print("Continuing to scheduler...")

    # Schedule the main function to run weekdays at 9:15 AM (before market open at 9:30 AM ET)
    schedule.every().monday.at("09:15").do(main)
    schedule.every().tuesday.at("09:15").do(main)
    schedule.every().wednesday.at("09:15").do(main)
    schedule.every().thursday.at("09:15").do(main)
    schedule.every().friday.at("09:15").do(main)
    
    print("Stock Bot scheduler started. Running daily at 09:15 AM (weekdays only).")
    print("Press Ctrl+C to stop.")
    
    # Keep the scheduler running
    while True:
        schedule.run_pending()
        time.sleep(60)  # Check every minute if a job needs to run